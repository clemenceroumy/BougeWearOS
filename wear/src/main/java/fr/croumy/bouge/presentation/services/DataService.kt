package fr.croumy.bouge.presentation.services

import fr.croumy.bouge.presentation.data.entities.WalkEntity
import fr.croumy.bouge.presentation.models.AccelerometerValue
import fr.croumy.bouge.presentation.models.Constants
import fr.croumy.bouge.presentation.repositories.WalkRepository
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.FlowPreview
import kotlinx.coroutines.MainScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.debounce
import kotlinx.coroutines.flow.filter
import kotlinx.coroutines.launch
import javax.inject.Inject
import javax.inject.Singleton

@OptIn(FlowPreview::class)
@Singleton
class DataService @Inject constructor(
    val walkRepository: WalkRepository
) {
    val _accelerometerValue = MutableStateFlow(AccelerometerValue())
    val accelerometerValue = _accelerometerValue.asStateFlow()

    val _heartrateValue = MutableStateFlow(0)
    val heartrateValue = _heartrateValue.asStateFlow()

    val firstStepTime = MutableStateFlow(System.currentTimeMillis())
    val lastStepTime = MutableStateFlow(System.currentTimeMillis())
    val _isWalking = MutableStateFlow(false)
    val isWalking = _isWalking.asStateFlow()

    val _currentWalk = MutableStateFlow(0)
    val currentWalk = _currentWalk.asStateFlow()

    val _totalSteps = MutableStateFlow(0)
    val totalSteps = _totalSteps.asStateFlow()


    init {
        MainScope().launch {
            currentWalk
                .filter { steps -> steps == 1  }
                .collect {
                    firstStepTime.value = System.currentTimeMillis()
                }
        }

        MainScope().launch {
            lastStepTime
                .debounce(Constants.TIME_STOPPED_WALKING)
                .collect { latestTime ->
                    _isWalking.value = false
                }

        }

        MainScope().launch {
            _isWalking
                .debounce(Constants.TIME_GAP_BETWEEN_WALKS)
                .collect {
                    if(_currentWalk.value > Constants.MINIMUM_STEPS_WALK) {
                        walkRepository.insertWalk(
                            WalkEntity(
                                uid = 0, // Auto-generated by Room
                                steps = _currentWalk.value,
                                start = firstStepTime.value,
                                end = lastStepTime.value
                            )
                        )
                    }
                    _currentWalk.value = 0
                }
        }
    }
}